clc
close all
clear all

file = fopen('data6.txt');
X = fscanf(file, '%f', [2 inf])';
fclose(file);

x = X(:,1);
y = X(:,2);
N = size(X);
K = N(2); % K = 2
N = N(1); % N = 100

figure;
scatter(x, y, '.');
title('Экспериментальные данные');
xlabel('X2');
ylabel('X1');

k = 4; % Выбрали визуально
C = zeros(k, K); % Центры кластеров
for i = 1:k
    C(i,:) = X(i,:); % Первые k значений исходных данных
end;

U = zeros(N, 2); % U [индекс кластера, расстояние от объекта до центра]
Q_prev = 1435; % Значение функционала качества кластеризации на предыдущем шаге
eps = 0.0001435; % Точность
m = 1; % Номер итерации
clust_rad = zeros(1, k); % Массив радиусов каждого из кластеров

while (true)
    R = zeros(1, k);
    % Расчёт расстояний до центров кластеров, заполнение матрицы U
    for i = 1:N 
        for n = 1:k
        R(n) = pdist([X(i,:); C(n,:)], 'minkowski', 4); % Расстояние i-го объекта до каждого из центров
        end 
        
        [d, n] = min(R); 
        U(i,1) = n; % Относим к кластеру, расстояние до которого минимально
        U(i,2) = R(n); % Расстояние до центра кластера
    end
    
    Q_m = 0; % Качество кластеризации на текущем шаге для p-го кластера
    QQ = 0; % Качество кластеризации на текущем шаге
    for p = 1:k
        Obj = find(U(:,1) == p); % Какие из объектов относятся к p-му кластеру (их порядковый номер)
        s = length(Obj); % Сколько таких относится
        singl_clust = zeros(1, s);
        X_clust = zeros(s, 2);
        for i = 1:s % Цикл по всем элементам p-го кластера
            singl_clust(i) = U(Obj(i), 2); % Расстояние до центра i-го кластера
            X_clust(i,:) = X(Obj(i),:); % Переписать в новую матрицу только те объекты которые в p-ом кластере 
        end;
        xex = pdist(X_clust); % Euclidean по умолчанию, расстояние между точками кластера
        Q_m = sum(xex); % Сумма расстояний
        clust_rad(p) = max(singl_clust); % Радиус кластера это максимальное расстояние от центра до какого-либо его объекта
        QQ = QQ + Q_m;
    end;
    
    % Если на двух соседних шагах качество кластеризации почти не изменилось, то дальнейший пересчёт нецелесообразен
    if abs(QQ - Q_prev) <= eps
        break;
    else % Если заданное качество не достигнуто, то пересчитываем центры как среднее по каждому признаку
        for l = 1:k 
             Obj = find(U(:,1)==l); % Какие из объектов относятся к l-му кластеру
             s = length(Obj); % Сколько таких относится
             for j = 1:K % По каждому признаку, то есть среднее по иксам и среднее по игрекам
                summa = 0;
                for i = 1:s 
                    summa = summa + X(Obj(i), j);
                end;
                C(l,j) = summa/s; % Среднее
             end;
        end;
        Q_prev = QQ; % Изменяем качество кластеризации
        m = m + 1;
    end;
end;

% Отображение найденных кластеров и центров
figure
gscatter(x, y, U(:,1), '', '.', 15);
hold on;
t = 0:(pi/180):2*pi;
for i = 1:k
  x = clust_rad(i)*cos(t) + C(i,1);
  y = clust_rad(i)*sin(t) + C(i,2);
  plot(x, y, 'k');
end;
scatter(C(:,1), C(:,2), 20, 'k', 'filled'); 
title('Найденные кластеры и их центры');
xlabel('X2');
ylabel('X1');
