clc
close all
clear all

[Xplot Yplot] = meshgrid(-30:0.25:30, -30:0.25:30);
Zplot = func(Xplot, Yplot);
surf(Xplot, Yplot, Zplot);

disp("Простой стохастический поиск")

N = 100000; % Число случайных точек
M = 2; % Размерность поиска

% Генерируется N случайных точек ksi1 в диапазоне [-30, 30]:
ksi1 = rand(M, N); 
A = -30;
B = 30;
% Вычисляются координаты stochXY случайных точек:
stochXY = zeros(M, N);
for k = 1:M
    for i=1:N
        stochXY(k,i) = A + (B - A)*ksi1(k,i);
    end
end
% Вычисляются значения функции stoсhZ для случайных точек:
stochZ = func(stochXY(1,:), stochXY(2,:));
% Находится минимальное значение Min функции stoсhZ и его индекс n:
[Min n] = min(stochZ);
Min
% Выводится информация о найденном минимуме и соответствующих ему координатах:
stochXY(:,n)

disp("Метод имитации отжига")

T = 50; % Максимальная температура
T0 = 0.0001; % Минимальная температура
v = 0.99; % Скорость понижения температуры
X0 = [20 20]; % Начальное приближение
X = X0; % Текущее решение
l = 0; % Счетчик итераций
while (T >= T0) % Пока T не станет меньше T0:
    l = l + 1;
    % Генерируются случайные векторы z и ksi2
    z = randn(2,1);
    ksi2 = rand(2,1);
    % Предлагается новое решение Xnew, сдвинутое от текущего X с учетом z,
    % T и ksi2:
    Xnew = X;
    flag = 0;
    for k = 1:M
        % Xnew(k) = X(k) + z(k)*T;
        Xnew(k) = X(k) + z(k)*T*((1 + l/T)^(2*ksi2(k) - 1) - 1);
        % Проверяется выход Xnew за границы допустимого диапазона:
        if ((A > Xnew(k))||(B < Xnew(k))) % выход за границы условия
            flag = 1;
        end
    end
    % Если выход за границы, то цикл повторяется.
    if (flag == 1)
        continue; % Переход в начало цикла
    end
    % Вычисляются значения функции F и Fnew для текущего и нового решений:
    F = func(X(:,1), X(:,2));
    Fnew = func(Xnew(:,1), Xnew(:,2));
    % Вычисляется разность значений deltaE:
    deltaE = Fnew - F;
    if (deltaE < 0) % Если deltaE меньше 0 (новое решение лучше), то X обновляется до Xnew
        X = Xnew;
    else
        % Если deltaE больше 0 (новое решение хуже), то с вероятностью
        % exp(-deltaE/T) решение X обновляется до Xnew:
        P = exp(-deltaE/T);
        if (rand < P) % Случайным образом разыгрывается принятие решения из запрещённой области
            X = Xnew;
        else
            % T понижается по закону v*T:
            T = v*T;
        end
    end  
end
X
func(X(1), X(2))
l
